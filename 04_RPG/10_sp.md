# **10_spber**

**【game.dart】**

プレーヤーと敵の頭上にゲージを表示する

```dart

player1.add(HpBar(
  target: player1,
  barSize: Vector2(70, 10),
  offset: Vector2(0, -PLAYER_SIZE_Y / 2 - 12),
));
// ⭐️追加
player1.add(SpBar(
  target: player1,
  barSize: Vector2(70, 8),
  offset: Vector2(0, -PLAYER_SIZE_Y / 2), // HPのすぐ下あたり
));
player2.add(HpBar(
  target: player2,
  barSize: Vector2(70, 10),
  offset: Vector2(0, -PLAYER_SIZE_Y / 2 - 12),
));
// ⭐️追加
player2.add(SpBar(
  target: player2,
  barSize: Vector2(70, 8),
  offset: Vector2(0, -PLAYER_SIZE_Y / 2),
));

//省略

// ⭐️一番下に追加
abstract class SpProvider {
  int get currentSp;
  int get maxSp;
}

```

**【player.dart】**


```dart

// ⭐️SpProvider追加
class Player extends SpriteComponent
    with HasGameRef<MainGame>, KeyboardHandler
    implements HealthProvider, SpProvider {


  int maxHp = 100;
  int hp = 100;

  // ⭐️追加
  int maxSp = 30;
  int sp = 0;

  @override
  int get currentHp => hp;

  // ⭐️追加
  @override
  int get currentSp => sp;
  

```

**【player.dart】**


```dart

import 'package:flutter/material.dart';//⭐️追加

class Player extends SpriteComponent
    with HasGameRef<MainGame>, KeyboardHandler
    implements HealthProvider {

  //⭐️追加
  Player(this.data);
  final CharacterData data;

```

**【game.dart】**

```dart

class MainGame extends FlameGame with HasKeyboardHandlerComponents {
  final BuildContext context;
  MainGame(this.context);

  late final CameraComponent cameraComponent;
  Player player = Player(PlayerList[0]);  //⭐️修正

  Teki? currentEnemy;


  //省略

Future<void> objectRemove() async {
    await CameraRemove();

    case "main":
      for (int i = 0; i < 1; i++) {
        BackScreenImg _backscreenimg = BackScreenImg(BackGroundlist[1], i);
        await world.add(_backscreenimg);
      }

      player = Player(PlayerList[0]); //⭐️修正
      await world.add(player);

      CameraOn = true;

      break;
    case "battle":
      CameraBackScreen _backscreenimg = CameraBackScreen(BackGroundlist[2]);
      await world.add(_backscreenimg);

      player1 = Player(PlayerList[0]) //⭐️修正
        ..keyboardEnabled = false
        ..position = Vector2(SCREENSIZE_X / 2 + 100, SCREENSIZE_Y - 200);

      player2 = Player(PlayerList[1]) //⭐️修正
        ..keyboardEnabled = false
        ..position = Vector2(SCREENSIZE_X / 2 + 400, SCREENSIZE_Y - 200);


```

**【teki.dart】**

```dart

import 'package:flutter/material.dart';//⭐️追加

void applyDamage(int dmg, {bool crit = false}) {
    _hp = (_hp - dmg).clamp(0, _maxHp);

    final parentToUse = parent ?? this;
    final worldPos = position + Vector2(0, -size.y / 2 - 8);

    parentToUse.add(DamagePopup(
      '-$dmg',
      color: crit ? Colors.amber : Colors.white,
      crit: crit,
      
      startOffset: worldPos -
          (parentToUse is PositionComponent
              ? (parentToUse as PositionComponent).position
              : Vector2.zero()),
      duration: 0.8,
      rise: 28,
    )
        
        );

    if (_hp <= 0) {
      removeFromParent();
    }
  }

```

**【ui.dart】**

```dart

class DamagePopup extends TextComponent {
  DamagePopup(
    String text, {
    this.color = Colors.white,
    this.duration = 0.8,
    this.rise = 24.0,
    Vector2? startOffset,
    this.crit = false,
  })  : startOffset = startOffset ?? Vector2(0, -32),
        super(
          text: text,
          anchor: Anchor.center,
        ) {
    textRenderer = TextPaint(
      style: TextStyle(
        color: color.withOpacity(1.0),
        fontSize: crit ? 16 : 12,
        fontWeight: crit ? FontWeight.w900 : FontWeight.w700,
        shadows: const [Shadow(blurRadius: 2, offset: Offset(1, 1))],
      ),
    );
  }

  final Color color;
  final double duration;
  final double rise;
  final Vector2 startOffset;
  final bool crit;

  double _elapsed = 0.0;
  double _opacity = 1.0;

  @override
  Future<void> onLoad() async {
    position = startOffset;

    // クリティカルなら出現時に拡大演出
    if (crit) {
      scale = Vector2.all(0.6);
      add(
        ScaleEffect.to(
          Vector2.all(1.0),
          EffectController(duration: 0.12, curve: Curves.easeOutBack),
        ),
      );
    }
  }

  @override
  void update(double dt) {
    super.update(dt);

    // 経過時間
    _elapsed += dt;

    // 上に移動
    position.y -= (rise / duration) * dt;

    // フェードアウト（線形に透明にする）
    _opacity = (1.0 - _elapsed / duration).clamp(0.0, 1.0);

    // duration 経過後に削除
    if (_elapsed >= duration) {
      removeFromParent();
    }
  }

  @override
  void render(Canvas canvas) {
    // 半透明描画（現在の _opacity を適用）
    final paint = Paint()..color = color.withOpacity(_opacity);
    final textStyle = TextStyle(
      color: paint.color,
      fontSize: crit ? 16 : 12,
      fontWeight: crit ? FontWeight.w900 : FontWeight.w700,
      shadows: const [Shadow(blurRadius: 2, offset: Offset(1, 1))],
    );

    final renderer = TextPaint(style: textStyle);
    renderer.render(canvas, text, Vector2.zero(), anchor: anchor);
  }
}


```

